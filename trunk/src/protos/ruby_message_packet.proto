// Copyright (c) 2011 Nohros Inc. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.
//
// The ruby server send messages that could be one of several different types.
// However, protocol buffers parsers cannot necessarily determine the type of a message based
// on the contents alone. We need to define a way to ensure that the ruby messages is correctly
// decoded/encoded by the ruby service. Essentially, with every message we send some header information
// that is encoded with protocol buffers.
//
// The basic structure of the message is:
//
// RubyMessagePacket
//   RubyMessagePacketHeader
//   RubyMessage
//     RubyMessageHeader
//     [A service define message]

package nohros.ruby;

import "google/protobuf/csharp_options.proto";

option (google.protobuf.csharp_file_options).namespace = "Nohros.Ruby";
option (google.protobuf.csharp_file_options).umbrella_classname = "RubyMessageProtos";
option (google.protobuf.csharp_file_options).multiple_files = true;

option optimize_for = SPEED;

// The message packet header. Contains information about the packed message. The
// ruby service host use this message packet to deliver a RubyMessage to a specific
// service. More specifically, it use the service property to find a service and then
// dispatch the message defined by the message property to the service.
/*message RubyMessageHeader {
    // Message ID, used to match request/response.
    optional int32 id = 1;

    // Total size (in bytes) of the message following this header.
    optional int32 size = 2;

    // The name of the service which this packet is associated.
    optional string service_name = 3;

    // A string used to identify the message. The meaning of the value stored into
    // this field is service-dependant. For example, a service could use this
    // field to store the name of a message and them use this value to
    // locate a class that could parse the message or it could store the name of
    // the class that can parse the message, so it could instantiate the class
    // directly throught reflection(in languages that support it, of course).
    optional string message_type = 4;
}*/

// Wraps a protobuf message into a envelope, which defines what is in the message and how to
// process it. The ruby server send messages that could be one of several different types. However,
// protocol buffers parsers cannot necessarily determine the type of a message based on the
// contents alone. This message was defined to ensure that the sent message is correctly
// decoded/encoded.
message RubyMessagePacket {
    // Total size of the packet(in bytes), not including the size of this field.
    optional int32 size = 1;

    // Message packet ID, used to match request/response.
    optional int32 id = 2;

    // The name of the service which this packet is associated.
    optional string service_name = 3;

    // A string used to identify the message. The meaning of the value stored into
    // this field is service-dependant. For example, a service could use this
    // field to store the name of a message and them use this value to
    // locate a class that could parse the message or it could store the name of
    // the class that can parse the message, so it could instantiate the class
    // directly throught reflection(in languages that support it, of course).
    optional string message_type = 4;

    // Service specific message serialized in protocol buffer format.
    optional string message = 5;
}