// Copyright (c) 2011 Nohros Inc. All rights reserved.
// Use of this source code is governed by a MIT-style license that can be
// found in the LICENSE file.
//
// The ruby server send messages that could be one of several different types.
// However, protocol buffers parsers cannot necessarily determine the type of a message based
// on the contents alone. We need to define a way to ensure that the ruby messages is correctly
// decoded/encoded by the ruby service. Essentially, with every message we send some header information
// that is encoded with protocol buffers.
//
// The basic structure of the message is:
//
// RubyMessagePacket
//   RubyMessagePacketHeader
//   RubyMessage
//     RubyMessageHeader
//     [A service define message]

package nohros.ruby;

import "google/protobuf/csharp_options.proto";
import "ruby_message_header.proto";

option (google.protobuf.csharp_file_options).namespace = "Nohros.Ruby";

option optimize_for = SPEED;

// Wraps a protobuf message into a envelope, which defines what is in the
// message and how to process it. The ruby server send messages that could be
// one of several different types. However, protocol buffers parsers cannot
// necessarily determine the type of a message based on the contents alone.
// This message was defined to ensure that the sent message is correctly
// decoded/encoded. This message is also used by the ruby service host to
// deliver the packed message to a specific service. More specifically, it use
// the service property to find the service which the message must be
// dispatched.
message RubyMessagePacket {
    // Total size of the packet(in bytes), not including the size of this field.
    optional int32 size = 1;

    // Total size (in bytes) of the message header(RubyMessageHeader).
    optional int32 message_size = 2;

    // The name of the service related packed with the message.
    optional string service = 3;

    // The message header.
    optional RubyMessageHeader header = 4;

    // Service specific message serialized in protocol buffer format.
    optional string message = 5;
}